{
  "version": 3,
  "sources": ["../../effector-forms/src/create-form-unit.ts", "../../effector-forms/src/field.ts", "../../effector-forms/src/validation.ts", "../../effector-forms/src/factory.ts", "../../effector-forms/src/react-hooks.ts"],
  "sourcesContent": ["import { createStore, createEvent, Domain, Store, Event } from \"effector\"\n\ntype CreateStoreParams<Value> = {\n    init: Value\n    domain?: Domain\n    existing?: Store<Value>\n}\n\nfunction store<Value>(\n    { init, domain, existing }: CreateStoreParams<Value>,\n    effectorData?: any\n) {\n    if (existing) {\n        return existing\n    }\n    return domain\n        ? domain.store(init, effectorData)\n        : createStore(init, effectorData)\n}\n\ntype CreateEventParams<Value> = {\n    domain?: Domain\n    existing?: Event<Value>\n}\n\nfunction event<Value>({ domain, existing }: CreateEventParams<Value>) {\n    if (existing) {\n        return existing\n    }\n    return domain ? domain.event<Value>() : createEvent<Value>()\n}\n\nexport const createFormUnit = {\n    store,\n    event,\n}\n", "import {\n    createStore,\n    Domain,\n    Event,\n    Store,\n    combine,\n    sample,\n    guard,\n    merge,\n} from \"effector\"\nimport {\n    ValidationError,\n    Field,\n    FieldData,\n    FieldConfig,\n    AnyFormValues,\n    ValidationEvent,\n    AddErrorPayload,\n    FieldUnitShape,\n} from \"./types\"\nimport { createCombineValidator } from \"./validation\"\nimport { createFormUnit } from \"./create-form-unit\"\n\n/**\n * @group Factories\n */\nexport function createField(\n    fieldName: string,\n    fieldConfig: FieldConfig<any>,\n    domain?: Domain,\n): Field<any> {\n    const initValue = typeof fieldConfig.init === \"function\"\n        ? fieldConfig.init()\n        : fieldConfig.init\n\n    const $value = createFormUnit.store({\n        domain,\n        existing: fieldConfig.units?.$value,\n        init: initValue,\n    }, {\n        sid: `${fieldName}-$value`\n    })\n\n    const $errors = createFormUnit.store<ValidationError[]>({\n        domain,\n        existing: fieldConfig.units?.$errors,\n        init: [],\n    }, {\n        sid: `${fieldName}-$errors`\n    })\n\n\n    const $firstError = $errors.map(\n        (errors) => errors[0] ? errors[0] : null\n    )\n\n    const $initValue = createFormUnit.store({\n        domain,\n        existing: fieldConfig.units?.$initValue,\n        init: initValue,\n    }, {\n        sid: `${fieldName}-$initValue`\n    })\n\n    const $touched = createFormUnit.store({\n        domain,\n        existing: fieldConfig.units?.$isTouched,\n        init: false,\n    }, {\n        sid: `${fieldName}-$touched`\n    })\n\n    const $isDirty = combine($value, $initValue,\n        (value, initValue) => value !== initValue,\n    )\n\n    const onChange = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.onChange,\n    })\n    const onBlur = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.onBlur,\n    })\n    const changed = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.changed,\n    })\n    const addError = createFormUnit.event<{\n        rule: string\n        errorText?: string\n    }>({\n        domain,\n        existing: fieldConfig.units?.addError,\n    })\n    const validate = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.validate,\n    })\n    const resetErrors = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.resetErrors,\n    })\n    const resetValue = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.resetValue,\n    })\n    const reset = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.reset,\n    })\n\n    const $isValid = $firstError.map((firstError) => firstError === null)\n    const $errorText = $firstError.map(\n        (firstError) => firstError?.errorText || \"\"\n    )\n\n    const $field = combine({\n        value: $value,\n        errors: $errors,\n        firstError: $firstError,\n        isValid: $isValid,\n        isDirty: $isDirty,\n        isTouched: $touched,\n    })\n\n    const unitShape: FieldUnitShape<any> = {\n        value: $value,\n        initValue: $initValue,\n        isValid: $isValid,\n        isDirty: $isDirty,\n        touched: $touched,\n        errors: $errors,\n        firstError: $firstError,\n        errorText: $errorText,\n        onChange,\n        onBlur,\n        addError,\n        validate,\n        reset,\n        resetErrors,\n        resetValue,\n    }\n\n    return {\n        changed,\n        \"name\": fieldName,\n        $initValue,\n        $value,\n        $errors,\n        $firstError,\n        $errorText,\n        $isValid,\n        $isDirty,\n        \"$isTouched\": $touched,\n        $touched,\n        \"$field\": $field as Store<FieldData<any>>,\n        onChange,\n        onBlur,\n        addError,\n        validate,\n        \"set\": onChange,\n        reset,\n        resetErrors,\n        resetValue,\n        \"filter\": fieldConfig.filter,\n        \"@@unitShape\": () => unitShape,\n    }\n}\n\ntype BindValidationParams = {\n    form: {\n        $values: Store<AnyFormValues>\n        submit: Event<void>\n        reset: Event<void>\n        resetValues: Event<void>\n        resetErrors: Event<void>\n        addErrors: Event<AddErrorPayload[]>\n        validate: Event<void>\n        validateOn?: ValidationEvent[]\n    }\n    field: Field<any>\n    fieldConfig: FieldConfig<any>\n}\n\nexport function bindValidation(\n    params: BindValidationParams, effectorData?: any\n): void {\n    const { form, field, fieldConfig } = params\n    const rules = fieldConfig.rules || []\n    const formValidationEvents = form.validateOn || [\"submit\"]\n    const fieldValidationEvents = fieldConfig.validateOn || []\n\n    const {\n        $value,\n        $errors,\n        onBlur,\n        changed,\n        addError,\n        validate,\n        resetErrors,\n        resetValue,\n        reset,\n    } = field\n\n    const rulesSources = typeof rules === \"function\"\n        ? createStore<any[]>([], { sid: `${field.name}-$rulesSources` })\n        : combine(\n            rules.map(({ source }, i) => {\n                const sid = `${field.name}-$rulesSources-${i}`\n                return source || createStore(null, { sid })\n            })\n        )\n\n    const validator = createCombineValidator(rules)\n    const eventsNames = [...formValidationEvents, ...fieldValidationEvents]\n    const validationEvents: Event<{\n        fieldValue: any\n        form: AnyFormValues\n        rulesSources: any[]\n    }>[] = []\n\n    if (eventsNames.includes(\"submit\")) {\n        const validationTrigger = sample({\n            source: combine({\n                fieldValue: $value,\n                form: form.$values,\n                rulesSources,\n            }),\n            clock: form.submit,\n        })\n\n        validationEvents.push(validationTrigger)\n    }\n\n    if (eventsNames.includes(\"blur\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: form.$values,\n                rulesSources,\n            }),\n            clock: onBlur,\n        }))\n    }\n\n    if (eventsNames.includes(\"change\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: form.$values,\n                rulesSources,\n            }),\n            clock: merge(\n                [changed, resetValue, form.resetValues]\n            ),\n        }))\n    }\n\n    validationEvents.push(sample({\n        source: combine({\n            fieldValue: $value,\n            form: form.$values,\n            rulesSources,\n        }),\n        clock: validate,\n    }))\n\n    validationEvents.push(sample({\n        source: combine({\n            fieldValue: $value,\n            form: form.$values,\n            rulesSources,\n        }),\n        clock: form.validate,\n    }))\n\n    const addErrorWithValue = sample({\n        source: $value,\n        clock: addError,\n        fn: (value, { rule, errorText }): ValidationError => ({\n            rule,\n            value,\n            errorText,\n        }),\n    })\n\n    const addErrorsWithValue = sample({\n        source: $value,\n        clock: form.addErrors,\n        fn: (value, errors) => ({\n            value,\n            newErrors: errors,\n        })\n    })\n\n    $errors\n        .on(\n            validationEvents,\n            (_, { form, fieldValue, rulesSources }) => validator(\n                fieldValue,\n                form,\n                rulesSources,\n            )\n        )\n        .on(addErrorWithValue, (errors, newError) => [newError, ...errors])\n        .on(addErrorsWithValue, (currErrors, { value, newErrors }) => {\n            const matchedErrors: ValidationError[] = []\n\n            for (const newError of newErrors) {\n                if (newError.field !== field.name) continue\n                matchedErrors.push({\n                    value,\n                    rule: newError.rule,\n                    errorText: newError.errorText,\n                })\n            }\n\n            return [...matchedErrors, ...currErrors]\n        })\n        .reset(resetErrors, form.reset, reset, form.resetErrors)\n\n    if (!eventsNames.includes(\"change\")) {\n        $errors.reset(changed)\n    }\n}\n\ntype BindChangeEventParams = {\n    field: Field<any>\n    form: {\n        setForm: Event<Partial<AnyFormValues>>\n        setInitialForm: Event<Partial<AnyFormValues>>\n        resetForm: Event<void>\n        resetTouched: Event<void>\n        resetValues: Event<void>\n    }\n}\n\nexport function bindChangeEvent({\n    field,\n    form,\n}: BindChangeEventParams): void {\n    const {\n        $value,\n        $initValue,\n        $touched,\n        onChange,\n        changed,\n        name,\n        reset,\n        resetValue,\n        filter\n    } = field\n\n    const {\n        setForm,\n        setInitialForm,\n        resetForm,\n        resetTouched,\n        resetValues\n    } = form\n\n    const resetValueWithInit = sample({\n        source: $initValue,\n        clock: merge([\n            reset,\n            resetValue,\n            resetValues,\n            resetForm\n        ]),\n    })\n\n    $touched\n        .on(changed, () => true)\n        .reset(reset, resetForm, resetTouched)\n\n    guard({\n        source: onChange,\n        filter: filter || (() => true),\n        target: changed,\n    })\n\n    $initValue\n        .on(setInitialForm, (curr, updateSet) => updateSet.hasOwnProperty(name)\n            ? updateSet[name]\n            : curr\n        )\n\n    $value\n        .on(changed, (_, value) => value)\n        .on(\n            [setForm, setInitialForm],\n            (curr, updateSet) => updateSet.hasOwnProperty(name)\n                ? updateSet[name]\n                : curr\n        )\n        .on(resetValueWithInit, (_, initValue) => initValue)\n}\n", "import { Store, combine } from \"effector\"\nimport {\n    ValidationError,\n    Rule,\n    AnyFields,\n    RuleResolver,\n} from \"./types\"\n\nexport function createCombineValidator<Value = any, Form = any>(\n    rulesOrResolver: Rule<Value, Form, any>[] | RuleResolver<Value, Form>\n) {\n    return (\n        value: Value,\n        form: Form,\n        rulesSources?: any[]\n    ): ValidationError<Value>[] => {\n\n        const errors: ValidationError<Value>[] = []\n        const rules = typeof rulesOrResolver === \"function\"\n            ? rulesOrResolver(value, form)\n            : rulesOrResolver\n\n        for (let i = 0; i < rules.length; i++) {\n            const rule = rules[i]\n            const source = rulesSources ? rulesSources[i] : null\n            const result = rule.validator(value, form, source)\n\n            if (typeof result === \"boolean\" && !result) {\n                errors.push({\n                    rule: rule.name,\n                    errorText: rule.errorText,\n                    value,\n                })\n            }\n\n            if (typeof result === \"object\" && !result.isValid) {\n                errors.push({\n                    rule: rule.name,\n                    errorText: result.errorText,\n                    value,\n                })\n            }\n        }\n\n        return errors\n    }\n}\n\n\nexport function eachValid(fields: AnyFields) {\n    const firstErrors: Store<ValidationError | null>[] = []\n\n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        const { $firstError } = fields[fieldName]\n        firstErrors.push($firstError)\n    }\n\n    const $firstErrors = combine(firstErrors)\n\n    return $firstErrors.map((errors) => errors.every(error => error === null))\n}\n", "import {\n    Event,\n    Store,\n    combine,\n    sample,\n    guard,\n    createStore,\n} from \"effector\"\nimport {\n    AnyFields,\n    AnyFormValues,\n    FormConfig,\n    Form,\n    AddErrorPayload,\n    FormUnitShape,\n} from \"./types\"\nimport { eachValid } from \"./validation\"\nimport {\n    createField,\n    bindValidation,\n    bindChangeEvent,\n} from \"./field\"\nimport { createFormUnit } from \"./create-form-unit\"\n\nfunction createFormValuesStore(\n    fields: AnyFields\n): Store<AnyFormValues> {\n    const shape: { [key: string]: Store<any> } = {}\n\n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        shape[fieldName] = fields[fieldName].$value\n    }\n\n    return combine(shape)\n}\n\n/**\n * This is the main factory in the library that creates\n * the forms shape according to the given configuration.\n * \n * Do not try to pass a type in the Values generic! Form types are inferred automatically from the passed \"fields\" object\n * \n * @param config - The form configuration object\n * @returns The shape of effector units\n * @example\n * \n * ```ts\n * const form = createForm({\n *      fields: {\n *          username: {\n *              init: \"\",\n *              rules: [\n *                  {\n *                      name: \"required\",\n *                      validator: (value: string) => Boolean(value)\n *                  }\n *              ]\n *          },\n *          bio: {\n *              init: \"\",\n *              rules: []\n *          }\n *      },\n *      validateOn: [\"change\"],\n * })\n * ```\n * @group Factories\n */\nexport function createForm<Values extends AnyFormValues>(\n    config: FormConfig<Values>\n) {\n    const {\n        filter: $filter,\n        domain,\n        fields: fieldsConfigs,\n        validateOn,\n        units,\n    } = config\n\n    const fields: AnyFields = {}\n\n    const dirtyFlagsArr: Store<boolean>[] = []\n    const touchedFlagsArr: Store<boolean>[] = []\n\n    // create units\n    for (const fieldName in fieldsConfigs) {\n        if (!fieldsConfigs.hasOwnProperty(fieldName)) continue\n\n        const fieldConfig = fieldsConfigs[fieldName]\n        const field = createField(fieldName, fieldConfig, domain)\n\n        fields[fieldName] = field\n        dirtyFlagsArr.push(field.$isDirty)\n        touchedFlagsArr.push(field.$touched)\n    }\n\n    const $form = createFormValuesStore(fields)\n    const $eachValid = eachValid(fields)\n    const $isFormValid = $filter\n        ? combine($eachValid, $filter, (valid, filter) => valid && filter)\n        : $eachValid\n    const $isDirty = combine(dirtyFlagsArr).map(\n        (dirtyFlags) => dirtyFlags.some(Boolean)\n    )\n    const $touched = combine(touchedFlagsArr).map(\n        (touchedFlags) => touchedFlags.some(Boolean)\n    )\n\n    const $meta = combine({\n        isValid: $eachValid,\n        isDirty: $isDirty,\n        touched: $touched,\n    })\n\n    const validate = createFormUnit.event<void>({\n        domain,\n        existing: units?.validate,\n    })\n\n    const submitForm = createFormUnit.event<void>({\n        domain,\n        existing: units?.submit,\n    })\n\n    const formValidated = createFormUnit.event({\n        domain,\n        existing: units?.formValidated,\n    })\n\n    const setInitialForm = createFormUnit.event<Partial<AnyFormValues>>({\n        domain,\n        existing: units?.setInitialForm as Event<Partial<AnyFormValues>>,\n    })\n\n    const setForm = createFormUnit.event<Partial<AnyFormValues>>({\n        domain,\n        existing: units?.setForm as Event<Partial<AnyFormValues>>,\n    })\n\n    const addErrors = createFormUnit.event<AddErrorPayload[]>({\n        domain,\n        existing: units?.addErrors,\n    })\n\n    const resetForm = createFormUnit.event({\n        domain,\n        existing: units?.reset,\n    })\n\n    const resetValues = createFormUnit.event({\n        domain,\n        existing: units?.resetValues,\n    })\n\n    const resetErrors = createFormUnit.event({\n        domain,\n        existing: units?.resetErrors,\n    })\n\n    const resetTouched = createFormUnit.event({\n        domain,\n        existing: units?.resetTouched,\n    })\n\n    const submitWithFormData = sample({\n        source: $form,\n        clock: submitForm,\n    })\n    const validateWithFormData = sample({\n        source: $form,\n        clock: validate\n    })\n\n    // bind units\n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n\n        const fieldConfig = fieldsConfigs[fieldName]\n        const field = fields[fieldName]\n\n        bindChangeEvent({\n            form: {\n                setForm,\n                setInitialForm,\n                resetForm,\n                resetTouched,\n                resetValues\n            },\n            field,\n        })\n        bindValidation({\n            form: {\n                $values: $form,\n                submit: submitForm,\n                reset: resetForm,\n                addErrors,\n                resetValues,\n                resetErrors,\n                validate,\n                validateOn,\n            },\n            fieldConfig,\n            field,\n        }, { sid: fieldName })\n    }\n\n    guard({\n        source: submitWithFormData as unknown as Event<Values>,\n        filter: $isFormValid,\n        // TODO: fix\n        target: formValidated,\n    })\n\n    guard({\n        source: validateWithFormData as unknown as Event<Values>,\n        filter: $isFormValid,\n        target: formValidated,\n    })\n\n    const unitShape: FormUnitShape<any> = {\n        isValid: $eachValid,\n        isDirty: $isDirty,\n        touched: $touched,\n        submit: submitForm,\n        reset: resetForm,\n        addErrors: addErrors,\n        validate,\n        setForm,\n        setInitialForm,\n        resetTouched,\n        resetValues,\n        resetErrors,\n        formValidated,\n    }\n\n    return {\n        fields,\n        \"$values\": $form,\n        $eachValid,\n        \"$isValid\": $eachValid,\n        \"$isDirty\": $isDirty,\n        \"$touched\": $touched,\n        $meta,\n        \"submit\": submitForm,\n        validate,\n        resetTouched,\n        addErrors,\n        \"reset\": resetForm,\n        resetValues,\n        resetErrors,\n        setForm,\n        setInitialForm,\n        \"set\": setForm,\n        formValidated,\n        \"@@unitShape\": () => unitShape,\n    } as unknown as Form<Values>\n}\n", "import { useUnit } from \"effector-react\"\nimport {\n    Field,\n    ValidationError,\n    AnyFormValues,\n    Form\n} from \"./types\"\n\ntype ErrorTextMap = {\n    [key: string]: string\n}\n\ntype AddErrorPayload = { rule: string; errorText?: string }\n\ntype ConnectedField<Value> = {\n    name: string\n    value: Value\n    errors: ValidationError<Value>[]\n    firstError: ValidationError<Value> | null\n    hasError: () => boolean\n    onChange: (v: Value) => Value\n    onBlur: (v: void) => void\n    errorText: (map?: ErrorTextMap) => string\n    addError: (p: AddErrorPayload) => AddErrorPayload\n    validate: (v: void) => void\n    isValid: boolean\n    isDirty: boolean\n    isTouched: boolean\n    touched: boolean\n    reset: (v: void) => void\n    set: (v: Value) => Value\n    resetErrors: (v: void) => void\n}\n\ntype ConnectedFields<Values extends AnyFormValues> = {\n    [K in keyof Values]: ConnectedField<Values[K]>\n}\n\ntype AnyConnectedFields = {\n    [key: string]: ConnectedField<any>\n}\n\n/**\n * @group Hooks\n */\nexport function useField<Value>(field: Field<Value>): ConnectedField<Value> {\n    const {\n        value,\n        errors,\n        firstError,\n        isValid,\n        isDirty,\n        isTouched: touched,\n    } = useUnit(field.$field)\n\n    return {\n        name: field.name,\n        value,\n        errors,\n        firstError,\n        isValid,\n        isDirty,\n        touched,\n        isTouched: touched,\n        onChange: useUnit(field.onChange),\n        onBlur: useUnit(field.onBlur),\n        addError: useUnit(field.addError),\n        validate: useUnit(field.validate),\n        reset: useUnit(field.reset),\n        set: useUnit(field.onChange),\n        resetErrors: useUnit(field.resetErrors),\n        hasError: () => {\n            return firstError !== null\n        },\n        errorText: (map) => {\n            if (!firstError) {\n                return \"\"\n            }\n            if (!map) {\n                return firstError.errorText || \"\"\n            }\n            if (map[firstError.rule]) {\n                return map[firstError.rule]\n            }\n            return firstError.errorText || \"\"\n        }\n    }\n\n}\n\ntype Result<Values extends AnyFormValues> = {\n    fields: ConnectedFields<Values>\n    values: Values\n    hasError: (fieldName?: keyof Values) => boolean\n    eachValid: boolean\n    isValid: boolean\n    isDirty: boolean\n    isTouched: boolean\n    touched: boolean\n    errors: (fieldName: keyof Values) => (\n        ValidationError<Values[typeof fieldName]>[]\n    )\n    error: (fieldName: keyof Values) => (\n        ValidationError<Values[typeof fieldName]>\n    ) | null\n    errorText: (fieldName: keyof Values, map?: ErrorTextMap) => string\n    submit: (p: void) => void\n    reset: (p: void) => void\n    setForm: (p: Partial<Values>) => Partial<Values>\n    set: (p: Partial<Values>) => Partial<Values>\n    formValidated: (p: Values) => Values\n}\n\n/**\n * @group Hooks\n */\nexport function useForm<Values extends AnyFormValues>(\n    form: Form<Values>\n): Result<Values> {\n    const connectedFields = {} as AnyConnectedFields\n    const values = {} as AnyFormValues\n\n    for (const fieldName in form.fields) {\n        if (!form.fields.hasOwnProperty(fieldName)) continue\n        const field = form.fields[fieldName]\n        const connectedField = useField(field)\n        connectedFields[fieldName] = connectedField\n        values[fieldName] = connectedField.value\n    }\n\n    const {\n        isValid: eachValid,\n        isDirty,\n        touched,\n    } = useUnit(form.$meta)\n\n\n    const hasError = (fieldName?: string): boolean => {\n        if (!fieldName) {\n            return !eachValid\n        }\n        if (connectedFields[fieldName]) {\n            return Boolean(connectedFields[fieldName].firstError)\n        }\n        return false\n    }\n\n    const error = (fieldName: string) => {\n        if (connectedFields[fieldName]) {\n            return connectedFields[fieldName].firstError\n        }\n        return null\n    }\n\n    const errors = (fieldName: string) => {\n        if (connectedFields[fieldName]) {\n            return connectedFields[fieldName].errors\n        }\n        return []\n    }\n\n    const errorText = (fieldName: string, map?: ErrorTextMap) => {\n        const field = connectedFields[fieldName]\n        if (!field) {\n            return \"\"\n        }\n        if (!field.firstError) {\n            return \"\"\n        }\n        if (!map) {\n            return field.firstError.errorText || \"\"\n        }\n        if (map[field.firstError.rule]) {\n            return map[field.firstError.rule]\n        }\n        return field.firstError.errorText || \"\"\n    }\n\n    return {\n        fields: connectedFields as ConnectedFields<Values>,\n        values,\n        hasError,\n        eachValid,\n        isValid: eachValid,\n        isDirty,\n        isTouched: touched,\n        touched,\n        errors,\n        error,\n        errorText,\n        reset: useUnit(form.reset),\n        submit: useUnit(form.submit),\n        setForm: useUnit(form.setForm),\n        set: useUnit(form.setForm), // set form alias\n        formValidated: useUnit(form.formValidated),\n    } as Result<Values>\n}\n"],
  "mappings": "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",
  "names": ["createFormUnit", "store", "init", "domain", "existing", "effectorData", "and", "sid", "createStore", "event", "createEvent", "createField", "fieldName", "fieldConfig", "_fieldConfig$units", "_fieldConfig$units2", "_fieldConfig$units3", "_fieldConfig$units4", "_fieldConfig$units5", "_fieldConfig$units6", "_fieldConfig$units7", "_fieldConfig$units8", "_fieldConfig$units9", "_fieldConfig$units10", "_fieldConfig$units11", "_fieldConfig$units12", "initValue", "$value", "units", "name", "$errors", "$firstError", "map", "errors", "$initValue", "$touched", "$isTouched", "$isDirty", "combine", "value", "or", "onChange", "onBlur", "changed", "addError", "validate", "resetErrors", "resetValue", "reset", "$isValid", "firstError", "$errorText", "errorText", "$field", "isValid", "isDirty", "isTouched", "unitShape", "touched", "set", "filter", "bindValidation", "params", "form", "field", "rules", "formValidationEvents", "validateOn", "fieldValidationEvents", "rulesSources", "source", "i", "validator", "rulesOrResolver", "length", "rule", "result", "push", "eventsNames", "validationEvents", "includes", "validationTrigger", "sample", "fieldValue", "$values", "clock", "submit", "merge", "resetValues", "addErrorWithValue", "fn", "addErrorsWithValue", "addErrors", "newErrors", "on", "_", "newError", "currErrors", "matchedErrors", "bindChangeEvent", "setForm", "setInitialForm", "resetForm", "resetTouched", "resetValueWithInit", "guard", "target", "curr", "updateSet", "hasOwnProperty", "createForm", "config", "$filter", "fields", "fieldsConfigs", "dirtyFlagsArr", "touchedFlagsArr", "$form", "shape", "$eachValid", "firstErrors", "every", "error", "$isFormValid", "valid", "dirtyFlags", "some", "Boolean", "touchedFlags", "$meta", "submitForm", "formValidated", "submitWithFormData", "validateWithFormData", "useField", "useUnit", "hasError", "useForm", "connectedFields", "values", "connectedField", "eachValid"]
}
