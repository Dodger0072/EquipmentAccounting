import {
  i
} from "./chunk-6ZY3V6AZ.js";
import {
  $,
  S,
  m,
  p,
  u,
  x
} from "./chunk-XPMEAQWN.js";
import "./chunk-DRWLMN53.js";
import "./chunk-G3PMV62Z.js";

// node_modules/effector-forms/dist/index.mjs
var a = { store: function({ init: e, domain: i2, existing: s }, o) {
  return s || (i2 ? i2.store(e, { and: o, sid: "-efg263" }) : p(e, { and: o, sid: "-dyefrw" }));
}, event: function({ domain: e, existing: r }) {
  return r || (e ? e.event({ sid: "-y6riru" }) : u({ sid: "-y6rhv4" }));
} };
function d(r, i2, s) {
  var o, n, t, d2, l2, u3, c2, m3, v2, f, h, $2;
  const g = "function" == typeof i2.init ? i2.init() : i2.init, V = a.store({ domain: s, existing: null === (o = i2.units) || void 0 === o ? void 0 : o.$value, init: g }, { and: { sid: `${r}-$value` }, name: "$value", sid: "-qmuyz8" }), x2 = a.store({ domain: s, existing: null === (n = i2.units) || void 0 === n ? void 0 : n.$errors, init: [] }, { and: { sid: `${r}-$errors` }, name: "$errors", sid: "-vpp9qr" }), E = x2.map((e) => e[0] ? e[0] : null), p2 = a.store({ domain: s, existing: null === (t = i2.units) || void 0 === t ? void 0 : t.$initValue, init: g }, { and: { sid: `${r}-$initValue` }, name: "$initValue", sid: "yr2fi7" }), y = a.store({ domain: s, existing: null === (d2 = i2.units) || void 0 === d2 ? void 0 : d2.$isTouched, init: false }, { and: { sid: `${r}-$touched` }, name: "$touched", sid: "-q2zc60" }), T = m({ and: [V, p2, (e, r2) => e !== r2], or: { name: "$isDirty", sid: "cgx1r6" } }), k = a.event({ domain: s, existing: null === (l2 = i2.units) || void 0 === l2 ? void 0 : l2.onChange }, { name: "onChange", sid: "fko8ie" }), F = a.event({ domain: s, existing: null === (u3 = i2.units) || void 0 === u3 ? void 0 : u3.onBlur }, { name: "onBlur", sid: "-kwhocu" }), b = a.event({ domain: s, existing: null === (c2 = i2.units) || void 0 === c2 ? void 0 : c2.changed }, { name: "changed", sid: "svcdu2" }), w = a.event({ domain: s, existing: null === (m3 = i2.units) || void 0 === m3 ? void 0 : m3.addError }, { name: "addError", sid: "utax3x" }), D = a.event({ domain: s, existing: null === (v2 = i2.units) || void 0 === v2 ? void 0 : v2.validate }, { name: "validate", sid: "-al4q5y" }), j = a.event({ domain: s, existing: null === (f = i2.units) || void 0 === f ? void 0 : f.resetErrors }, { name: "resetErrors", sid: "-8bnwk6" }), q = a.event({ domain: s, existing: null === (h = i2.units) || void 0 === h ? void 0 : h.resetValue }, { name: "resetValue", sid: "-5k4ef5" }), S2 = a.event({ domain: s, existing: null === ($2 = i2.units) || void 0 === $2 ? void 0 : $2.reset }, { name: "reset", sid: "-t5gx88" }), O = E.map((e) => null === e), B = E.map((e) => (null == e ? void 0 : e.errorText) || ""), C = m({ and: [{ value: V, errors: x2, firstError: E, isValid: O, isDirty: T, isTouched: y }], or: { name: "$field", sid: "-3lcsvv" } }), I = { value: V, initValue: p2, isValid: O, isDirty: T, touched: y, errors: x2, firstError: E, errorText: B, onChange: k, onBlur: F, addError: w, validate: D, reset: S2, resetErrors: j, resetValue: q };
  return { changed: b, name: r, $initValue: p2, $value: V, $errors: x2, $firstError: E, $errorText: B, $isValid: O, $isDirty: T, $isTouched: y, $touched: y, $field: C, onChange: k, onBlur: F, addError: w, validate: D, set: k, reset: S2, resetErrors: j, resetValue: q, filter: i2.filter, "@@unitShape": () => I };
}
function l(i2, n) {
  const { form: t, field: a2, fieldConfig: d2 } = i2, l2 = d2.rules || [], u3 = t.validateOn || ["submit"], c2 = d2.validateOn || [], { $value: m3, $errors: v2, onBlur: f, changed: h, addError: $2, validate: g, resetErrors: V, resetValue: x2, reset: E } = a2, p2 = "function" == typeof l2 ? p([], { and: { sid: `${a2.name}-$rulesSources` }, name: "rulesSources", sid: "8mhplv" }) : m({ and: [l2.map(({ source: e }, i3) => {
    const s = `${a2.name}-$rulesSources-${i3}`;
    return e || p(null, { and: { sid: s }, sid: "kjwg5z" });
  })], or: { name: "rulesSources", sid: "93jc02" } }), y = (T = l2, (e, r, i3) => {
    const s = [], o = "function" == typeof T ? T(e, r) : T;
    for (let n2 = 0; n2 < o.length; n2++) {
      const t2 = o[n2], a3 = i3 ? i3[n2] : null, d3 = t2.validator(e, r, a3);
      "boolean" != typeof d3 || d3 || s.push({ rule: t2.name, errorText: t2.errorText, value: e }), "object" != typeof d3 || d3.isValid || s.push({ rule: t2.name, errorText: d3.errorText, value: e });
    }
    return s;
  });
  var T;
  const k = [...u3, ...c2], F = [];
  if (k.includes("submit")) {
    const r = x({ and: [{ source: m({ and: [{ fieldValue: m3, form: t.$values, rulesSources: p2 }], or: { name: "source", sid: "a7in27" } }), clock: t.submit }], or: { name: "validationTrigger", sid: "ag2jep" } });
    F.push(r);
  }
  k.includes("blur") && F.push(x({ and: [{ source: m({ and: [{ fieldValue: m3, form: t.$values, rulesSources: p2 }], or: { name: "source", sid: "pcyjof" } }), clock: f }], or: { sid: "-mjjw0q" } })), k.includes("change") && F.push(x({ and: [{ source: m({ and: [{ fieldValue: m3, form: t.$values, rulesSources: p2 }], or: { name: "source", sid: "-uzr82o" } }), clock: S([h, x2, t.resetValues], { name: "clock", sid: "mklqro" }) }], or: { sid: "-7v5lsp" } })), F.push(x({ and: [{ source: m({ and: [{ fieldValue: m3, form: t.$values, rulesSources: p2 }], or: { name: "source", sid: "-gsekud" } }), clock: g }], or: { sid: "6c71fm" } })), F.push(x({ and: [{ source: m({ and: [{ fieldValue: m3, form: t.$values, rulesSources: p2 }], or: { name: "source", sid: "-323jeq" } }), clock: t.validate }], or: { sid: "a4k0l6" } }));
  const b = x({ and: [{ source: m3, clock: $2, fn: (e, { rule: r, errorText: i3 }) => ({ rule: r, value: e, errorText: i3 }) }], or: { name: "addErrorWithValue", sid: "symbs8" } }), w = x({ and: [{ source: m3, clock: t.addErrors, fn: (e, r) => ({ value: e, newErrors: r }) }], or: { name: "addErrorsWithValue", sid: "-6mh24c" } });
  v2.on(F, (e, { form: r, fieldValue: i3, rulesSources: s }) => y(i3, r, s)).on(b, (e, r) => [r, ...e]).on(w, (e, { value: r, newErrors: i3 }) => {
    const s = [];
    for (const e2 of i3) e2.field === a2.name && s.push({ value: r, rule: e2.rule, errorText: e2.errorText });
    return [...s, ...e];
  }).reset(V, t.reset, E, t.resetErrors), k.includes("change") || v2.reset(h);
}
function u2({ field: e, form: r }) {
  const { $value: i2, $initValue: t, $touched: a2, onChange: d2, changed: l2, name: u3, reset: c2, resetValue: m3, filter: v2 } = e, { setForm: f, setInitialForm: h, resetForm: $2, resetTouched: g, resetValues: V } = r, x2 = x({ and: [{ source: t, clock: S([c2, m3, V, $2], { name: "clock", sid: "3kodws" }) }], or: { name: "resetValueWithInit", sid: "oge6qb" } });
  a2.on(l2, () => true).reset(c2, $2, g), $({ and: [{ source: d2, filter: v2 || (() => true), target: l2 }], or: { sid: "-kx8mil" } }), t.on(h, (e2, r2) => r2.hasOwnProperty(u3) ? r2[u3] : e2), i2.on(l2, (e2, r2) => r2).on([f, h], (e2, r2) => r2.hasOwnProperty(u3) ? r2[u3] : e2).on(x2, (e2, r2) => r2);
}
function c(r) {
  const { filter: i2, domain: o, fields: t, validateOn: c2, units: m3 } = r, v2 = {}, f = [], h = [];
  for (const e in t) {
    if (!t.hasOwnProperty(e)) continue;
    const r2 = d(e, t[e], o);
    v2[e] = r2, f.push(r2.$isDirty), h.push(r2.$touched);
  }
  const $2 = function(r2) {
    const i3 = {};
    for (const e in r2) r2.hasOwnProperty(e) && (i3[e] = r2[e].$value);
    return m({ and: [i3], or: { sid: "39yu4w" } });
  }(v2), g = function(r2) {
    const i3 = [];
    for (const e in r2) {
      if (!r2.hasOwnProperty(e)) continue;
      const { $firstError: s } = r2[e];
      i3.push(s);
    }
    return m({ and: [i3], or: { name: "$firstErrors", sid: "-1vosn1" } }).map((e) => e.every((e2) => null === e2));
  }(v2), V = i2 ? m({ and: [g, i2, (e, r2) => e && r2], or: { name: "$isFormValid", sid: "j5pxai" } }) : g, x2 = m({ and: [f], or: { name: "$isDirty", sid: "il8stq" } }).map((e) => e.some(Boolean)), E = m({ and: [h], or: { name: "$touched", sid: "2no1yv" } }).map((e) => e.some(Boolean)), p2 = m({ and: [{ isValid: g, isDirty: x2, touched: E }], or: { name: "$meta", sid: "yii6e7" } }), y = a.event({ domain: o, existing: null == m3 ? void 0 : m3.validate }, { name: "validate", sid: "5z7ulc" }), T = a.event({ domain: o, existing: null == m3 ? void 0 : m3.submit }, { name: "submitForm", sid: "-xys7v0" }), k = a.event({ domain: o, existing: null == m3 ? void 0 : m3.formValidated }, { name: "formValidated", sid: "-2r221i" }), F = a.event({ domain: o, existing: null == m3 ? void 0 : m3.setInitialForm }, { name: "setInitialForm", sid: "-q10ho7" }), b = a.event({ domain: o, existing: null == m3 ? void 0 : m3.setForm }, { name: "setForm", sid: "l2bjv0" }), w = a.event({ domain: o, existing: null == m3 ? void 0 : m3.addErrors }, { name: "addErrors", sid: "n5fjqj" }), D = a.event({ domain: o, existing: null == m3 ? void 0 : m3.reset }, { name: "resetForm", sid: "pfltj4" }), j = a.event({ domain: o, existing: null == m3 ? void 0 : m3.resetValues }, { name: "resetValues", sid: "-s67s76" }), q = a.event({ domain: o, existing: null == m3 ? void 0 : m3.resetErrors }, { name: "resetErrors", sid: "hulqf7" }), S2 = a.event({ domain: o, existing: null == m3 ? void 0 : m3.resetTouched }, { name: "resetTouched", sid: "2gwck3" }), O = x({ and: [{ source: $2, clock: T }], or: { name: "submitWithFormData", sid: "foyubg" } }), B = x({ and: [{ source: $2, clock: y }], or: { name: "validateWithFormData", sid: "-mn7k5o" } });
  for (const e in v2) {
    if (!v2.hasOwnProperty(e)) continue;
    const r2 = t[e], i3 = v2[e];
    u2({ form: { setForm: b, setInitialForm: F, resetForm: D, resetTouched: S2, resetValues: j }, field: i3 }), l({ form: { $values: $2, submit: T, reset: D, addErrors: w, resetValues: j, resetErrors: q, validate: y, validateOn: c2 }, fieldConfig: r2, field: i3 });
  }
  $({ and: [{ source: O, filter: V, target: k }], or: { sid: "4sls6r" } }), $({ and: [{ source: B, filter: V, target: k }], or: { sid: "4vwjqx" } });
  const C = { isValid: g, isDirty: x2, touched: E, submit: T, reset: D, addErrors: w, validate: y, setForm: b, setInitialForm: F, resetTouched: S2, resetValues: j, resetErrors: q, formValidated: k };
  return { fields: v2, $values: $2, $eachValid: g, $isValid: g, $isDirty: x2, $touched: E, $meta: p2, submit: T, validate: y, resetTouched: S2, addErrors: w, reset: D, resetValues: j, resetErrors: q, setForm: b, setInitialForm: F, set: b, formValidated: k, "@@unitShape": () => C };
}
function m2(e) {
  const { value: r, errors: i2, firstError: s, isValid: o, isDirty: n, isTouched: a2 } = i(e.$field);
  return { name: e.name, value: r, errors: i2, firstError: s, isValid: o, isDirty: n, touched: a2, isTouched: a2, onChange: i(e.onChange), onBlur: i(e.onBlur), addError: i(e.addError), validate: i(e.validate), reset: i(e.reset), set: i(e.onChange), resetErrors: i(e.resetErrors), hasError: () => null !== s, errorText: (e2) => s ? e2 && e2[s.rule] ? e2[s.rule] : s.errorText || "" : "" };
}
function v(e) {
  const r = {}, i2 = {};
  for (const s2 in e.fields) {
    if (!e.fields.hasOwnProperty(s2)) continue;
    const o2 = m2(e.fields[s2]);
    r[s2] = o2, i2[s2] = o2.value;
  }
  const { isValid: s, isDirty: o, touched: n } = i(e.$meta);
  return { fields: r, values: i2, hasError: (e2) => e2 ? !!r[e2] && Boolean(r[e2].firstError) : !s, eachValid: s, isValid: s, isDirty: o, isTouched: n, touched: n, errors: (e2) => r[e2] ? r[e2].errors : [], error: (e2) => r[e2] ? r[e2].firstError : null, errorText: (e2, i3) => {
    const s2 = r[e2];
    return s2 && s2.firstError ? i3 && i3[s2.firstError.rule] ? i3[s2.firstError.rule] : s2.firstError.errorText || "" : "";
  }, reset: i(e.reset), submit: i(e.submit), setForm: i(e.setForm), set: i(e.setForm), formValidated: i(e.formValidated) };
}
export {
  c as createForm,
  m2 as useField,
  v as useForm
};
//# sourceMappingURL=effector-forms.js.map
